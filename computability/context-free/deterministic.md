---
title: Deterministic Context-Free Language
TARGET DECK: Obsidian::STEM
FILE TAGS: computability::cfl
tags:
  - cfl
  - computability
  - grammar
---

## Overview

A **deterministic pushdown automaton** (DPDA) is a $6$-tuple $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$, where $Q$, $\Sigma$, $\Gamma$, and $F$ are all finite sets, and

1. $Q$ is the set of states,
2. $\Sigma$ is the input alphabet,
3. $\Gamma$ is the stack alphabet,
4. $\delta \colon Q \times \Sigma_\epsilon \times \Gamma_\epsilon \rightarrow (Q \times \Gamma_\epsilon) \cup \{ \varnothing \}$ is the transition function,
5. $q_0 \in Q$ is the start state, and
6. $F \subseteq Q$ is the set of accept states.

For every $q \in Q$, $a \in \Sigma$, and $x \in \Gamma$, exactly one of the values is not $\varnothing$:

* $\delta(q, a, x)$;
* $\delta(q, a, \epsilon)$, an **$\epsilon$-stack move**;
* $\delta(q, \epsilon, x)$, an **$\epsilon$-input move**;
* $\delta(q, \epsilon, \epsilon)$, an $\epsilon$-stack and $\epsilon$-input move.

A [[computability/index|language]] is called **deterministic context-free** if a DPDA recognizes it.

%%ANKI
Basic
From a recognition perspective, what is a deterministic context-free language?
Back: A language recognized by a deterministic pushdown automaton.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622395-->
END%%

%%ANKI
Basic
From a generation perspective, what is a deterministic context-free language?
Back: A language generated by an LR($1$) grammar.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100926-->
END%%

%%ANKI
Basic
From a generation perspective, what is an endmarked deterministic context-free language?
Back: A language generated by a deterministic context-free grammar.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100930-->
END%%

%%ANKI
Basic
What is DCFL an acronym for?
Back: **D**eterministic **C**ontext-**F**ree **L**anguage.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622396-->
END%%

%%ANKI
Basic
What is DPDA an acronym for?
Back: **D**eterministic **P**ush**d**own **a**utomaton.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622398-->
END%%

%%ANKI
Basic
A DPDA introduces what additional data structure to a finite automaton?
Back: A stack.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622399-->
END%%

%%ANKI
Basic
How are deterministic pushdown automatons typically abbreviated?
Back: As DPDAs.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622400-->
END%%

%%ANKI
Basic
The formal definition of a DPDA is a tuple of what length?
Back: Six.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622401-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $Q$?
Back: A finite set of states.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622402-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $\Sigma$?
Back: A finite set corresponding to the input alphabet.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622403-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $\Gamma$?
Back: A finite set corresponding to the stack alphabet.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622404-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $\delta$?
Back: The transition function.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622405-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $q_0$?
Back: The start state.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622406-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. How does $q_0$ relate to other members of the tuple?
Back: $q_0 \in Q$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622407-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is $F$?
Back: The set of final states.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622408-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. How does $F$ relate to other members of the tuple?
Back: $F \subseteq Q$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622409-->
END%%

%%ANKI
Basic
What two alphabets are associated with a DPDA?
Back: The input alphabet and the stack alphabet.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622410-->
END%%

%%ANKI
Basic
Writing a symbol to a DPDA's stack corresponds to what ADT operation?
Back: Pushing.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622411-->
END%%

%%ANKI
Basic
Removing a symbol from a DPDA's stack corresponds to what ADT operation?
Back: Popping.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622412-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is the domain of $\delta$?
Back: $Q \times \Sigma_\epsilon \times \Gamma_\epsilon$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622413-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is the codomain of $\delta$?
Back: $(Q \times \Gamma_\epsilon) \cup \{\varnothing\}$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622414-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is an $\epsilon$-input move?
Back: A move of form $\delta(q, \epsilon, x)$ for some $x \in \Gamma$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622415-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. What is an $\epsilon$-stack move?
Back: A move of form $\delta(q, a, \epsilon)$ for some $a \in \Sigma$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622416-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA, $q \in Q$, $\gamma \in \Gamma$. How is $\epsilon$ in $\delta(q, \epsilon, \gamma)$ interpreted?
Back: As not advancing the input tape.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622417-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA, $q \in Q$, $\sigma \in \Sigma$. How is $\epsilon$ in $\delta(q, \sigma, \epsilon)$ interpreted?
Back: As not popping the stack.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622418-->
END%%

%%ANKI
Basic
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. For every $q \in Q$, $a \in \Sigma$, and $x \in \Gamma$, exactly one of what four values must not be $\varnothing$?
Back:
1. $\delta(q, a, x)$
2. $\delta(q, a, \epsilon)$
3. $\delta(q, \epsilon, x)$
4. $\delta(q, \epsilon, \epsilon)$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622419-->
END%%

%%ANKI
Basic
Suppose $R$ is a regular language. Is $R$ a DCFL?
Back: Yes.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622420-->
END%%

%%ANKI
Basic
Ignore missing edges. What is wrong with the following DPDA state?
![[dpda-invalid-state1.png]]
Back: If $a$ is the next input symbol and $x$ is top stack symbol, the next transition is ambiguous.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622421-->
END%%

%%ANKI
Basic
Ignore missing edges. What is wrong with the following DPDA state?
![[dpda-invalid-state2.png]]
Back: If $a$ is the next input symbol and $x$ is top stack symbol, the next transition is ambiguous.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622422-->
END%%

%%ANKI
Basic
Ignore missing edges. What is wrong with the following DPDA state?
![[dpda-valid-state1.png]]
Back: N/A. This is valid.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622423-->
END%%

%%ANKI
Basic
Consider the following DPDA snippet. What name is given to the kind of transition?
![[dpda-epsilon-input.png]]
Back: An $\epsilon$-input move.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622424-->
END%%

%%ANKI
Basic
Consider the following DPDA snippet. What name is given to the kind of transition?
![[dpda-epsilon-stack.png]]
Back: An $\epsilon$-stack move.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622425-->
END%%

%%ANKI
Basic
Suppose a DPDA can make an $\epsilon$-move in a certain situation. What other moves are prohibited?
Back: Those in the same situation that involve processing a symbol instead of $\epsilon$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622426-->
END%%

%%ANKI
Basic
How does the transition function of a DPDA indicate no action?
Back: By outputting $\varnothing$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622427-->
END%%

%%ANKI
Cloze
Let $\langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ be a DPDA. For every $q \in Q$, $a \in \Sigma$, and $x \in \Gamma$, one of {$\delta(q, a, x)$}, {$\delta(q, \epsilon, x)$}, {$\delta(q, a, \epsilon)$}, or {$\delta(q, \epsilon, \epsilon)$} must be nonempty.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622428-->
END%%

%%ANKI
Basic
For a given input, what happens if a DPDA has no legal move?
Back: It rejects the input.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622429-->
END%%

%%ANKI
Basic
What two conditions make a DPDA reject a given input?
Back:
1. It doesn't enter an accept state at the end of the input.
2. It fails to read the entire input.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622430-->
END%%

%%ANKI
Basic
Suppose a DPDA reads the entirety of its input. Why might it still fail?
Back: It doesn't enter an accept state.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766801622397-->
END%%

%%ANKI
Basic
What two conditions make a DPDA fail to read in its input?
Back:
1. It attempts to pop an empty stack.
2. It makes an endless sequence of $\epsilon$-input moves.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766802922431-->
END%%

%%ANKI
Basic
With respect to DPDAs, what is a hanging situation?
Back: One in which the DPDA attempts to pop an empty stack.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766802922434-->
END%%

%%ANKI
Basic
With respect to DPDAs, what is a looping situation?
Back: One in which the DPDA makes an endless sequence of $\epsilon$-input moves.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766802922436-->
END%%

%%ANKI
Basic
With respect to DPDAs, a looping situation expects what kind of moves?
Back: Only $\epsilon$-input moves.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222537-->
END%%

%%ANKI
Basic
With respect to DPDAs, what is an accepting looping situation?
Back: A looping situation in which at least one final state is in the corresponding loop.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222541-->
END%%

%%ANKI
Basic
With respect to DPDAs, what is a rejecting looping situation?
Back: A looping situation in which no final state is in the corresponding loop.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222542-->
END%%

%%ANKI
Cloze
With respect to DPDAs, {1:hanging} is to {2:deadlock} whereas {2:looping} is to {1:livelock}.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807344593-->
END%%

%%ANKI
Basic
We want a DPDA that reads in its entire input. How do we fix halting?
Back: By pushing a special symbol onto the stack at the start.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807829721-->
END%%

%%ANKI
Basic
We want a DPDA that reads in its entire input. How do we fix looping?
Back: Redirect accepting looping situations to an accept state and rejecting looping situations to a reject state.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807829725-->
END%%

%%ANKI
Basic
What kind of mathematical entity is a looping situation of a DPDA?
Back: An ordered pair.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766808746307-->
END%%

%%ANKI
Basic
Suppose $\langle q, x \rangle$ is a looping situation of a DPDA. What is $q$?
Back: A state.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766808746312-->
END%%

%%ANKI
Basic
Suppose $\langle q, x \rangle$ is a looping situation of a DPDA. What is $x$?
Back: The top stack symbol.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766808746315-->
END%%

%%ANKI
Basic
Suppose $\langle q, x \rangle$ is a looping situation of a DPDA. What does this mean?
Back: A cycle starting at $q$ exists in which no input is read and the stack from $x$ down remains the same.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766808746317-->
END%%

## Deterministic CFG

A **deterministic context-free grammar** (DCFG) is a [[computability/context-free/index#Grammar|CFG]] such that every [[computability/context-free/index#Valid Strings|valid string]] has a forced handle.

If we restrict our attention to [[computability/index#Languages|prefix-free]] languages, they are equivalent to DPDAs in their descriptive power. By adding an endmarker to a language, we ensure the resulting language is prefix-free.

%%ANKI
Basic
What is DCFG an acronym for?
Back: **D**eterministic **C**ontext-**F**ree **G**rammar.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100935-->
END%%

%%ANKI
Basic
What is a deterministic context-free grammar?
Back: A CFG such that every valid string has a forced handle.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767399166437-->
END%%

%%ANKI
Basic
*Why* isn't it possible for a DCFG to be ambiguous?
Back: By definition every valid string in a DCFG has a forced handle.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767399166439-->
END%%

%%ANKI
Basic
Let $G$ be a deterministic context-free grammar. What does $L(G)$ denote?
Back: The language generated by $G$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100939-->
END%%

%%ANKI
Basic
Let $G$ be a deterministic context-free grammar. How is its generated DCFL denoted?
Back: As $L(G)$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100944-->
END%%

%%ANKI
Basic
With respect to DCFLs, what is the generating model?
Back: LR($1$) grammars.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100948-->
END%%

%%ANKI
Basic
With respect to prefix-free DCFLs, what is the generating model?
Back: DCFGs.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100952-->
END%%

%%ANKI
Basic
With respect to DCFLs, what is the recognizing model?
Back: Deterministic pushdown automata.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767233100955-->
END%%

%%ANKI
Basic
Which of DPDAs or DCFGs are more powerful?
Back: DPDAs.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842472-->
END%%

%%ANKI
Basic
Under what subclass of DCFLs are DPDAs and DCFGs equivalent in power?
Back: The prefix-free DCFLs.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842476-->
END%%

%%ANKI
Basic
DCFGs are equivalent to what subclass of DCFLs?
Back: Those that are prefix-free.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842480-->
END%%

%%ANKI
Basic
How is it we know an endmarked DCFL can be generated by a DCFG?
Back: An endmarked DCFL is prefix-free.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842482-->
END%%

%%ANKI
Basic
Which DCFLs do *not* have a DCFG?
Back: Those that are not prefix-free.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842485-->
END%%

%%ANKI
Basic
*Why* doesn't language $\{a^nb^n \mid n \geq 0\}$ have a DCFG?
Back: It is not prefix-free. Namely, $\epsilon$ is a prefix of e.g. $ab$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842488-->
END%%

%%ANKI
Basic
*Why* doesn't language $\{a^nb^n \mid n \geq 1\}$ have a DCFG?
Back: N/A. It does since its a prefix-free DCFL.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234842491-->
END%%

%%ANKI
Basic
*Why* must a DCFL be prefix-free to be generated by a DCFG?
Back: Otherwise it's ambiguous when to shift the input or reduce.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767234958403-->
END%%

### Dotted Rules

A **dotted rule** is a rule in a CFG augmented with a dot ($\bullet$) between two of the symbols found on its RHS. For example, rule $B \rightarrow u_1 u_2 \cdots u_k$ containing $k$ symbols has $k + 1$ dotted rules: $$\begin{align*} B & \rightarrow \mathop\bullet u_1 u_2 \cdots u_k \\ B & \rightarrow u_1 \mathop\bullet u_2 \cdots u_k \\ & \vdots \\ B & \rightarrow u_1 u_2 \cdots u_k \mathop\bullet \end{align*}$$

%%ANKI
Basic
What is a dotted rule of a CFG?
Back: A rule in $G$ with an additional dot ($\bullet$) placed before or after a symbol in its RHS.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644370-->
END%%

%%ANKI
Basic
Let $B \rightarrow u_1 u_2 \cdots u_k$ be a rule of a CFG. How many corresponding dotted rules are there?
Back: $k + 1$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644378-->
END%%

%%ANKI
Basic
Typically speaking, what is the dot of a dotted rule used to denote?
Back: A cursor indicating the current "spot" of a rule.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644383-->
END%%

%%ANKI
Basic
Let $S \rightarrow AbC$ be a rule of a CFG. What are its corresponding dotted rules?
Back: $$\begin{align*} S & \rightarrow \mathop\bullet A b C \\ S & \rightarrow A \mathop\bullet b C \\ S & \rightarrow A b \mathop\bullet C \\ S & \rightarrow A b C \mathop\bullet \end{align*}$$
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644388-->
END%%

### DK-Test

Every CFG $G$ has a corresponding NFA and DFA, typically denoted $K$ and $DK$ respectively, that can identify handles. That is, $K$ and $DK$ accept input $w$ if and only if $w$ is the prefix of some valid string $v = wy$ and $w$ ends with a handle of $v$. $DK$ is constructed from $K$ using the standard [[regular#Power Set Construction|power set construction]].

$K$'s states correspond to the dotted rules of $G$. It has a special start state with an $\epsilon$-move to $\boxed{S_0 \rightarrow \mathop\bullet u}$ for every rule involving start variable $S_0$. Subsequent transitions are of one of two forms:

* A **shift-move** appears for every terminal/variable $a$ and every rule $B \rightarrow u a v$: $$\large \boxed{B \rightarrow u \mathop\bullet a v} \;\overset{a}{\longrightarrow}\; \boxed{B \rightarrow u a \mathop\bullet v}$$
* An **$\epsilon$-move** appears for all rules $B \rightarrow uCv$ and $C \rightarrow r$: $$\large \boxed{B \rightarrow u \mathop\bullet C v} \;\overset{\epsilon}{\longrightarrow}\; \boxed{C \rightarrow \mathop\bullet r}$$

The accept states are all $\boxed{\boxed{B \rightarrow u \mathop\bullet}}$ corresponding to a completed rule. They have no outgoing transitions.

%%ANKI
Basic
Let $G$ be a CFG. What does its associated DFA $DK$ recognize?
Back: Prefixes of valid strings ending with a handle.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644393-->
END%%

%%ANKI
Basic
Let $G$ be a CFG. Why is its DFA $DK$ named the way it is?
Back: It's a mnemonic for **d**eterministic $K$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644399-->
END%%

%%ANKI
Basic
Who invented the $DK$-test?
Back: Donald Knuth.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644404-->
END%%

%%ANKI
Basic
Let $G$ be a CFG. What does its associated NFA $K$ recognize?
Back: Prefixes of valid strings ending with a handle.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644409-->
END%%

%%ANKI
Cloze
Let $G$ be a CFG. Its associated DFA $DK$ recognizes $w$ if and only if:
1. {$v = wy$ for some valid string $v$}, and
2. {$w$ ends with a handle of $v$}.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644433-->
END%%

%%ANKI
Basic
Given the following context, what do the states of $K$ correspond to?
1. $G$ is a CFG.
2. $K$ is $G$'s associated NFA with respect to the $DK$-test.
Back: The dotted rules of $G$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644445-->
END%%

%%ANKI
Basic
Given the following context, how many transitions move out of $K$'s start state?
1. $G$ is a CFG in CNF.
2. $K$ is $G$'s associated NFA with respect to the $DK$-test.
Back: One for each rule beginning with $G$'s start variable.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644455-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, how is $DK$ constructed from $K$?
Back: The power set construction.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644463-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what kind of mathematical entity is $K$?
Back: An NFA.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644471-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what kind of mathematical entity is $DK$?
Back: A DFA.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644478-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, how many types of transitions are there in $K$?
Back: Two.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644485-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what are the two kinds of transitions in $K$?
Back: Shift-moves and $\epsilon$-moves.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644491-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, how many shift-moves are there in $K$?
Back: One for each terminal/variable $a$ and rule $B \rightarrow u a v$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644498-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, how many $\epsilon$-moves are there in $K$?
Back: One for each pair of rules $B \rightarrow u C v$ and $C \rightarrow r$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644504-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what kind of move in $K$ does the following depict? $$\large \boxed{B \rightarrow u \mathop\bullet a v} \;\overset{a}{\longrightarrow}\; \boxed{B \rightarrow u a \mathop\bullet v}$$
Back: A shift-move.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644510-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what kind of move in $K$ does the following depict? $$\large \boxed{B \rightarrow u \mathop\bullet C v} \;\overset{\epsilon}{\longrightarrow}\; \boxed{C \rightarrow \mathop\bullet r}$$
Back: An $\epsilon$-move.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644517-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what are the accept states of $K$?
Back: Those corresponding to dotted rules of form $B \rightarrow u \mathop\bullet$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644523-->
END%%

%%ANKI
Basic
Given the following context, how many accept states are in $K$?
1. $G$ is a CFG.
2. $K$ is $G$'s associated NFA with respect to the $DK$-test.
Back: One for each rule in $G$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767622644529-->
END%%

%%ANKI
Basic
Given the following context, how many completed rules are in each of $DK$'s accept states?
1. $G$ is a CFG.
2. $DK$ is $G$'s associated DFA with respect to the $DK$-test.
Back: At least one.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767647636738-->
END%%

%%ANKI
Basic
Given the following context, how many completed rules are in each of $DK$'s accept states?
1. $G$ is a DCFG.
2. $DK$ is $G$'s associated DFA with respect to the $DK$-test.
Back: Exactly one.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767647636746-->
END%%

%%ANKI
Basic
Given the following context, how many dotted rules are in each of $DK$'s states?
1. $G$ is a DCFG.
2. $DK$ is $G$'s associated DFA with respect to the $DK$-test.
Back: At least one.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767647636753-->
END%%

%%ANKI
Cloze
With respect to the $DK$-test, each accept state of $DK$ contains:
1. {exactly one completed rule}, and
2. {no dotted rule in which a terminal symbol immediately follows the dot}.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547105-->
END%%

%%ANKI
Basic
What can we conclude about CFG $G$ if $G$ passes the $DK$-test?
Back: $G$ is a DCFG.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547114-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, *why* is it important every accept state contains exactly one completed rule?
Back: Otherwise it's ambiguous which of the corresponding reductions to choose.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547120-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, *why* is it important every accept state does not contain a dotted rule with a terminal immediately after the dot?
Back: Otherwise it's ambiguous whether to shift or to reduce.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547128-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what two ambiguities are we trying to find?
Back: Conflicting reductions or shift-reduce conflicts.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547132-->
END%%

%%ANKI
Basic
With respect to the $DK$-test, what does a "shift-reduce conflict" refer to?
Back: An ambiguous situation in which a parser would not know whether to shift or reduce.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547136-->
END%%

%%ANKI
Basic
Let $G$ be a CFG. What test is used to determine if $G$ is deterministic?
Back: The $DK$-test.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767650547140-->
END%%

## LR Grammar

An **LR($k$) grammar** is a [[context-free/index|context-free grammar]] such that the [[computability/context-free/index#Reductions|handle]] of every [[computability/context-free/index#Valid Strings|valid string]] is forced by lookahead $k$.

LR($1$) grammars are equivalent to DPDAs in power. For every $k > 1$, an LR($k$) grammar can be converted to a DPDA and hence is also equivalent to LR($1$). For this reason, If $k$ is omitted, it is assumed $k = 1$.

%%ANKI
Basic
DCFGs are better known as what?
Back: LR($0$) grammars.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656040977-->
END%%

%%ANKI
Basic
What is the "L" in "LR($k$)" grammar an abbreviation for?
Back: **L**eft-to-right input processing.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014945-->
END%%

%%ANKI
Basic
What is the "R" in "LR($k$)" grammar an abbreviation for?
Back: **R**ightmost derivations (i.e. leftmost reductions).
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014948-->
END%%

%%ANKI
Basic
What is the "$k$" in "LR($k$)" grammar an abbreviation for?
Back: The number of lookahead symbols.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014951-->
END%%

%%ANKI
Basic
What is an LR($k$) grammar?
Back: A CFG such that the handle of every valid string is forced by lookahead $k$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014954-->
END%%

%%ANKI
Cloze
A(n) {DCFG} is equivalent to an LR({$0$}) grammar.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014957-->
END%%

%%ANKI
Basic
Let $G$ be an LR($k$) grammar. What value of $k$ implies $G$ is a DCFG?
Back: $k = 0$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014960-->
END%%

%%ANKI
Basic
How does the power of LR($0$) grammars relate to that of LR($1$) grammars?
Back: The latter is strictly stronger than the former.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014963-->
END%%

%%ANKI
Basic
How does the power of LR($1$) grammars relate to that of LR($2$) grammars?
Back: They generate the same class of languages.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014967-->
END%%

%%ANKI
Basic
With respect to the generating power of LR($k$) grammars, what value of $k$ is strongest?
Back: LR($k$) grammars are equivalent in power for all $k \geq 1$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014971-->
END%%

%%ANKI
Basic
How many lookahead symbols is assumed when describing an "LR grammar"?
Back: One.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014975-->
END%%

%%ANKI
Basic
With respect to LR($k$) grammars, *why* is $k$ assumed to be $1$ if unspecified?
Back: LR($k$) grammars are equivalent in generating power for all $k \geq 1$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1767656014981-->
END%%

## Closure Operations

Let $A$ and $B$ be deterministic context free languages over alphabet $\Sigma$. Such languages are closed under the following:

* Complementation: $\overline{A} = \{ w \in \Sigma^* \mid w \not\in A \}$
* Endmark: $A{\dashv} = \{ w{\dashv} \mid w \in A \}$
	* In fact, $A$ is a DCFL if and only if $A{\dashv}$ is a DCFL.

Furthermore, the intersection of a DCFL with a [[regular|regular language]] is deterministic context-free.

%%ANKI
Basic
Are DCFLs closed under union?
Back: No.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222543-->
END%%

%%ANKI
Basic
How do we show DCFLs are closed under union (using say DCFGs $A$ and $B$)?
Back: N/A. DCFLs are not generally closed under union.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222544-->
END%%

%%ANKI
Basic
Are DCFLs closed under intersection?
Back: No.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222546-->
END%%

%%ANKI
Basic
How do we show DCFLs are closed under intersection (using say DCFGs $A$ and $B$)?
Back: N/A. DCFLs are not generally closed under intersection.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222547-->
END%%

%%ANKI
Basic
Are DCFLs closed under reversal?
Back: No.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222548-->
END%%

%%ANKI
Basic
How do we show DCFLs are closed under reversal (using say DCFG $A$)?
Back: N/A. DCFLs are not generally closed under reversal.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222549-->
END%%

%%ANKI
Basic
Are DCFLs closed under complement?
Back: Yes.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222550-->
END%%

%%ANKI
Basic
Are DCFLs closed under concatenation?
Back: No.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222551-->
END%%

%%ANKI
Basic
How do we show DCFLs are closed under concatenation (using say DCFGs $A$ and $B$)?
Back: N/A. DCFLs are not generally closed under concatenation.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222552-->
END%%

%%ANKI
Basic
Are DCFLs closed under Kleene star?
Back: No.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222553-->
END%%

%%ANKI
Basic
How do we show DCFLs are closed under Kleene star (using say DCFG $A$)?
Back: N/A. DCFLs are not generally closed under Kleene star.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222554-->
END%%

%%ANKI
Basic
Let $C$ be a DCFL and $R$ be a regular language. What can be said about $C \cap R$?
Back: It must be deterministic context-free.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222555-->
END%%

%%ANKI
Basic
Let $D$ be a DCFL and $R$ be a regular language. What strategy is used to show $D \cap R$ is a DCFL?
Back: Use the product construction to form a DPDA that recognizes $D \cap R$.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222556-->
END%%

%%ANKI
Basic
Let $D$ be a DCFL, $R$ be a regular language, and $P$ be the DPDA recognizing $D \cap R$. What are $P$'s states?
Back: $Q \times Q'$, where $Q$ is the states of $D$'s DPDA and $Q'$ is the states of $R$'s DFA.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222557-->
END%%

%%ANKI
Basic
Let $D$ be a DCFL and $R$ be a regular language. What construction is used to show $D \cap R$ is deterministic context-free?
Back: The product construction.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766807222558-->
END%%

%%ANKI
Basic
How does adding endmarkers (i.e. $\dashv$) change the power of DPDAs?
Back: N/A. It doesn't.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766857888300-->
END%%

%%ANKI
Basic
How does adding endmarkers (i.e. $\dashv$) make designing DPDAs simpler?
Back: They allow us to know when the input string ends.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766857888301-->
END%%

%%ANKI
Basic
Let $A$ be a DCFL. What can be said about $A{\dashv}$?
Back: $A{\dashv}$ is also a DCFL.
Reference: Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).
<!--ID: 1766857888302-->
END%%

## Bibliography

* Michael Sipser, _Introduction to the Theory of Computation_, Third edition, international edition (Cengage Learning, 2013).